---
title: "Assignment 1: Oakland's TOD"
author: "Alex Nelms"
date: "9/8/2021"
output: github_document
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(tigris_class = "sf")
```

```{r setup_package, warning = FALSE, message = FALSE}
library(tidyverse)
library(tidycensus)
library(sf)
library(tmap)
library(ggrepel)
library(tigris)
library(RColorBrewer)

mile = 5280
sqmile = 27878400

set.seed(717)

mapTheme <- function(base_size = 12) {
  theme(
    text = element_text( color = "black"),
    plot.title = element_text(size = 16,colour = "black"),
    plot.subtitle=element_text(face="italic"),
    plot.caption=element_text(hjust=0),
    axis.ticks = element_blank(),
    panel.background = element_blank(),axis.title = element_blank(),
    axis.text = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(colour = "black", fill=NA, size=2),
    strip.text.x = element_text(size = 14))
}

plotTheme <- function(base_size = 12) {
  theme(
    text = element_text( color = "black"),
    plot.title = element_text(size = 16,colour = "black"),
    plot.subtitle = element_text(face="italic"),
    plot.caption = element_text(hjust=0),
    axis.ticks = element_blank(),
    
    panel.background = element_blank(),
    panel.grid.major = element_line("grey80", size = 0.1),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(colour = "black", fill=NA, size=2),
    strip.background = element_rect(fill = "grey80", color = "white"),
    strip.text = element_text(size=12),
    
    axis.title = element_text(size=12),
    axis.text = element_text(size=10),
    
    
    plot.background = element_blank(),
    
    legend.background = element_blank(),
    legend.title = element_text(colour = "black", face = "italic"),
    legend.text = element_text(colour = "black", face = "italic"),
    
    strip.text.x = element_text(size = 14)
  )
}

key_file = "C:/Users/nelms/OneDrive/Code/census_api_key.txt"
census_key = readChar(key_file, file.info(key_file)$size)
census_api_key(census_key, overwrite = TRUE)
```

# Bay Area Rapid Transit (BART) in the East Bay

### A Transit Oriented Development Study

------------------------------------------------------------------------

## 1. Data Wrangling

### 1.A Transit Routes & Stops

Transit Routes & Stops are for the Bay Area Regional Transit, the San Francisco Bay Area's hybrid subway-commuter rail.
Looking at this transportation system allows us to focus on both urban cetners and their immediate suburbs.
The data was sourced from the regional [Metropolitan Transportation Commission](https://opendata.mtc.ca.gov/ "MTC Open Data Portal").

```{r 1A_transit_import}

#stop_path = "https://services3.arcgis.com/i2dkYWmb4wHvYPda/arcgis/rest/services/transitstops_existing_planned_2021/FeatureServer/0/query?where=1%3D1&outFields=*&outSR=2227&f=geojson"
stop_path = 'C:/Users/nelms/OneDrive/Penn/MUSA-508/Files/SF-Bay_Transit-Stops-Major_2021.geojson'

#route_path = "https://services3.arcgis.com/i2dkYWmb4wHvYPda/arcgis/rest/services/transitroutes_01_2020/FeatureServer/0/query?where=1%3D1&outFields=*&outSR=2227&f=geojson"
route_path = 'C:/Users/nelms/OneDrive/Penn/MUSA-508/Files/BART_routes.geojson'

BART.stops =
  # from the MTC API, who sourced it from BART
  st_read(stop_path) %>%
  # only look at BART & weekday routes
  filter(agency_id == "BA", route_s_nm!="Blue-Sun", route_s_nm!='Beige') %>%
  mutate(
    route_s_nm = ifelse(
      route_s_nm=="Blue-Wkd/Sat", "Blue", 
      route_s_nm)
  ) %>%
  st_transform(., 2227)

# Projection is (NAD83) California State Plan, Zone 2 (in FEET)
# EPSG:2226
CA_crs = st_crs(BART.stops)
#cat(CA_crs$input, ', EPSG:', CA_crs$epsg)

BART.routes = 
  st_read(route_path) %>%
  filter(agency_id == "BA", route_s_nm!="Blue-Sun") %>%
  mutate(
    route_s_nm = ifelse(
      route_s_nm=="Blue-Wkd/Sat", "Blue", 
      route_s_nm)
  ) %>%
  st_transform(., CA_crs)
```

### 1.A 2 Prepare Transit & East Bay City Boundary Data

Narrowing down Census Tracts & Transit stations to the urban area of the Eastern San Francisco Bay Area *"East Bay"*: Oakland, Berkeley, and the immediate suburban cities of Alameda, Albany, Emeryville, and Albany.\*

```{r 1A_transit_prep, include = FALSE}

# PULL CITY BOUNDARIES FROM REGIONAL MTC OPEN DATA
#city_path = 'https://services3.arcgis.com/i2dkYWmb4wHvYPda/arcgis/rest/services/region_jurisdiction_clp/FeatureServer/0/query?where=1%3D1&outFields=jurname,fipco&outSR=2227&f=geojson'
city_path = 'C:/Users/nelms/OneDrive/Penn/MUSA-508/Files/EastBay_cities.geojson'
EB.cities = st_read(city_path) 

#EB.all    = st_read(city_path) %>% st_union(.) %>% st_transform(., CA_crs)

# NARROW AREAS TO MAJOR & MINOR CITIES
major_EB = c('Berkeley', 'Oakland')
minor_EB = c('Alameda', 'Albany', 'Emeryville', 'Piedmont')
is_EB = c(minor_EB, major_EB)
EB.cities = EB.cities[match(is_EB, EB.cities$jurname), ] %>%
  select( -fipco) %>%
  rename(
    city = jurname
  ) %>%
  st_transform(., CA_crs)
EB.cities$size = 'minor'
EB.cities[EB.cities$city %in% major_EB, 'size'] = 'major'

# NARROW STOPS TO .5 MILE OUTSIDE THESE CITIES
BART.stops =
  BART.stops %>%
  # .5 mile buffer + 1 foot
  st_filter(., st_buffer(st_union(EB.cities), dist=5280*.5+1)) %>%
  group_by(stop_nm,stop_id) %>%
  st_drop_geometry(.) %>%
  summarise(
    route_count = n_distinct(route_s_nm), # get routes used
    routes      = list(unique(route_s_nm))
  ) %>%
  merge(., BART.stops[,'stop_id'], by='stop_id') %>%
  distinct() %>% # remove duplicates
  st_as_sf()

# NARROW STOPS TO THESE CITIES 
BART.routes = st_intersection(BART.routes, st_buffer(st_union(EB.cities),5280*.5))

# CREATE CITY LABELS
EB.labels = 
  EB.cities %>%
  st_centroid(EB.cities) %>%
  rename(
    label = city
  ) %>%
  mutate(
       lon = map_dbl(geometry, ~st_centroid(.x)[[1]]),
       lat = map_dbl(geometry, ~st_centroid(.x)[[2]])
     )

```

### 1/2 Mile Buffers of BART Stops

```{r 1A.2_Buffers}

buffer_distance = .5

min_point_distances = function(
  input.geoms,
  input.ids,
  compare.geoms,
  compare.ids
){
  # GET DISTANCES OF TRANSIT STOPS AND THE FOCUS AREA BOUNDARY
  distances_matrix = 
    outer(input.geoms,
          compare.geoms,
          FUN=Vectorize(st_distance, USE.NAMES = FALSE))
  
  # CREATE MATRIX COLUMN & ROW NAMES
  rownames(distances_matrix) = input.ids
  colnames(distances_matrix) = compare.ids
  
  get_col = function(rowname, find_num){
    return(colnames(distances_matrix)[distances_matrix[rowname, ] == find_num])
  }
  get_col = Vectorize(get_col)
  distances_df =
    apply(distances_matrix, 1, min) %>% as.data.frame() %>%
    rename('distance'=1) %>%
    rownames_to_column('ID') %>%
    mutate(closest=get_col(ID, distance))
  
  return(distances_df)
}

EB.coords = EB.cities %>% 
    st_convex_hull() %>% 
    st_cast(., "MULTIPOINT") %>%
    st_union() %>%
    st_cast(., "POINT")

BARTstop_EBboundary_distances = min_point_distances(
  input.geoms = EB.coords,
  input.ids   = seq(from=1,to=length(EB.coords)),
  compare.geoms = BART.stops$geometry,
  compare.ids = BART.stops$stop_id
)
  
# GET LARGEST CLOSEST DISTANCE (MILES) BETWEEN STOPS AND BOUNDARY
max_min_BART_EB_dist = 
  max(BARTstop_EBboundary_distances$distance)/mile

# MINIMUM DISTANCE NEEDED TO BUFFER FROM TRANSIT STOPS AND COVER ALL FOCUS AREAS
# ASSUMES IN 1/2 or 1 MILE INTERVALS
buffer_max_distance = ceiling(max_min_BART_EB_dist)

# FUNCTION CREATING MULTIPLE RING BUFFERS FOR TRANSIT STOPS
# CYCLES THROUGH EACH DISTANCE ROW TO BUFFER & UNION
multiringbuffers_byrow = function(
  input.points, # BART Stops or any point
  buffer_distance=.5,
  buffer_max=5,
  # default fields & info for union
  union_default = data.frame(
    stop_id=c('ALL'),stop_nm=c('UNION'),
    route_count=c(0),routes=c(''))
){
  mile=5280
  # SEQUENCE VECTOR OF BUFFER RING LENGTHS
  buffer_distances = 
    seq(from=buffer_distance, 
        to=buffer_max, by=buffer_distance)
  
  # CYCLE THROUGH DISTANCES TO BUFFER EACH POINT
  # USE ST_DIFFERENCE TO CREATE RINGS
  # CREATE UNION ROW OF EACH DISTANCE
  for (current_buffer_distance in buffer_distances) {
    # GEOM OF SMALLER DISTANCE TO CREATE RING
    buffer.difference = 
      input.points %>% 
        st_buffer(
          (current_buffer_distance-buffer_distance)*mile
          ) %>% st_union() %>% st_sfc()
    # SF BUFFER OF EACH STOP
    buffer.new = 
      input.points %>%
      st_buffer(., current_buffer_distance*mile) %>%
        st_difference(., buffer.difference) %>%
      mutate(distance = current_buffer_distance)
    
    # SF BUFFER UNION FOR NEW ROW 
    buffer.union = 
      buffer.new %>%
        st_union() %>%
        st_difference(., buffer.difference) %>%
        st_sfc() %>%
      # cbind default union fields
      cbind(
        ., union_default %>%
          mutate(distance=current_buffer_distance)
        ) %>% st_as_sf() %>% 
      # reorder columns for rbind
      subset(., select=colnames(buffer.new))
    
    # rbind to all buffers
    if (current_buffer_distance==buffer_distance) {
      buffer.temp = 
        st_as_sf(rbind(
          buffer.union, 
          buffer.new))} 
    else 
      buffer.temp = 
      st_as_sf(rbind(
        buffer.temp, 
        buffer.union, 
        buffer.new))
  }
  # reset index
  row.names(buffer.temp) <- NULL
  return(buffer.temp)
}

buffer_distance = .5
BART.buffers = 
  multiringbuffers_byrow(
    BART.stops, buffer_distance=buffer_distance,
    buffer_max=buffer_max_distance)

buffer_distances = 
  seq(from=buffer_distance, to=buffer_max_distance, by=buffer_distance)

plot_limits = function(
  poly.geometry = EB.cities$geometry,
  # buffer between plot's limits and the geometry 
  # (in unit of geometry column)
  buffer = 0
  ){
  # creates bounding box
  poly.bbox = 
    poly.geometry %>% st_union() %>%
    # buffers the geometry so the ultimate plot has margins
    st_buffer(buffer) %>%
    st_bbox()
  return(
    # returns the 'coord_sf' function which you can add to any plot
    coord_sf(
      xlim = c(poly.bbox['xmin'], poly.bbox['xmax']),
      ylim = c(poly.bbox['ymin'], poly.bbox['ymax']),
      crs = st_crs(poly.geometry)
    ))}

buffer_breaks = c(0,buffer_distances)
buffer_labels =
  c(gsub("0.", ".", buffer_breaks))
#buffer_breaks = c(buffer_distances,buffer_max_distance+buffer_distance)

ggplot() + 
  geom_sf(
    data=EB.cities, fill='grey90') + 
  geom_sf(
    data=BART.routes, color='grey20', 
    alpha=.5, lwd=1.5) + 
  geom_sf(
    data=BART.buffers[BART.buffers$stop_id=='ALL',],
    fill='transparent', aes(color=distance), lwd=.75) + 
  geom_sf(
    data=BART.stops, fill='white',
    color='grey30', shape=21) + 
  scale_color_stepsn(
    #labels = buffer_labels,
    breaks = buffer_breaks,
    colors=brewer.pal(length(buffer_breaks),
                      name='Spectral')) + 
  mapTheme() + plot_limits()

```

### 1.B American Community Survey Census Tracts (2009 & 2019)

*Loading Census Tracts & Variables*

```{r 1B.1_Tracts}

# ACS VARIABLES TO FOCUS ON
acs_var = c(
  "B01001_001", # total pop
  # HOUSING
  "B19013_001", # median household income
  "B25001_001", # housing units
  "B25058_001", # Median Contract rent
  "B25071_001", # median rent as percent of household income
  "B07003_001", # total
  "B07003_004", # total same house 1 year
  # TRAVEL
  "B08135_001", # aggregate time to work
  "B08135_010", # aggregate time to work over 60 mins
  # DEMOGRAPHIC
  "B01001_010", # Male Age    22 to 24
  "B01001_011", # Male Age    25 to 29
  "B01001_012", # Male Age    30 to 34
  "B01001_034", # Female Age  22 to 24
  "B01001_035", # Female Age  25 to 29
  "B01001_036"  # Female Age  30 to 34
  # THIS SECTION OF MY CODE IS DEDICATED TO THE VARIABLES THAT COULD HAVE BEEN STUDIED IF TIDY CENSUS DIDNT HAVE ERRORS WITH THESE TABLES
  # Rest In Pieces
  ## "B08201_001", # household size
  ## "B08201_002", # households with not vehicle
  ## "B24114_001", # total occupations
  ## "B24114_068"  # total software developers
  )

# FUNCTION TO PULL EACH ACS YEAR'S CENSUS TRACTS
get_acs_year <- function(acs_year) {
  # TIDY CENSUS PULL
  #tracts.acs = 
  #    get_acs(
  #      geography = "tract", 
  #      variables = acs_var, 
  #      year=acs_year, state='CA', county='Alameda',
  #      geometry=T) %>%
  #    st_transform(CA_crs)
  
  directory = 'C:/Users/nelms/OneDrive/Penn/MUSA-508/Files'
  filename = gsub(" ","",paste('census', acs_year, '_tracts.geojson'))
  tract_path = file.path(directory, filename)
    
  tracts.acs = st_read(tract_path) 
  
  tracts.acs = 
    tracts.acs %>%
    dplyr::select( -NAME, -moe) %>%
    spread(variable, estimate)
  # GROUP BY GEOID TO FIX MULTIPOLYGON ISSUE
  tracts.acs =
    tracts.acs %>%
    group_by(GEOID) %>%
    summarise(
      year          = acs_year,
      tot_pop       = first(B01001_001), 
      med_HH_inc    = first(B19013_001),
      med_rent      = first(B25058_001),
      tot_units     = first(B25001_001),
      pct_60m_commute = first(B08135_010) / first(B08135_001), 
      tot_22_34yo   = first(B01001_010) + first(B01001_011) + first(B01001_012) 
        + first(B01001_034) + first(B01001_035) + first(B01001_036),
      pct_22_34yo   = tot_22_34yo/first(B01001_001),
      tot_moved     = first(B07003_001) - first(B07003_004),
      pct_moved     = tot_moved/first(B07003_001),
      pct_med_rent  = first(B25071_001),
      geometry      = st_union(geometry) # turn to multipoly
      )
  # REMOVE RAW ACS FIELDS
  non_raw_cols = 
    colnames(tracts.acs)[!startsWith(colnames(tracts.acs), "B")]
  tracts.acs = tracts.acs[non_raw_cols]
  
  return (tracts.acs)
}

# # ADD ACS EMPLOYMENT FIELDS THAT TIDYCENSUS WOULDN'T IMPORT
# get_acs_subinfo = function(acs_year){   
#   # local csv
#   directory = 'C:/Users/nelms/OneDrive/Penn/MUSA-508/Files'
#   filename = gsub(" ","",paste('census', acs_year, '_employment.csv'))
#   
#   focus_year = read.csv(file=file.path(directory, filename))
#   focus_year = 
#     focus_year %>%
#     dplyr::select( -NAME, -moe, -X) %>%
#     spread(variable, estimate)
#   focus_year = 
#     focus_year %>%
#     mutate(
#       # total employed people (16yr +)
#       tot_emp = C24050_001, 
#       # total employed people in information sector 
#       # includes (software, tech, media)
#       tot_emp_info = C24050_008, 
#       year = acs_year
#     )
#   # format GEOID like tidycensus
#   focus_year$GEOID = 
#     lapply(as.character(focus_year$GEOID), 
#            function(x) paste('0',x,sep=''))
#   # remove raw census columns
#   non_raw_cols = 
#     colnames(focus_year)[!startsWith(colnames(focus_year), "C")]
#   focus_year = focus_year[non_raw_cols]
#   
#   return(focus_year)
# }
 
tracts.all = rbind(
  get_acs_year(2009), 
  get_acs_year(2019)
  ) %>% st_as_sf()

# tracts.all = st_as_sf(merge(
#   tracts.all, 
#   rbind(get_acs_subinfo(2009), get_acs_subinfo(2019)), 
#                            by = c('GEOID','year'), all.x = TRUE))

```

### 1.B 2 Narrowing to the East Bay

*Select Tracts & Routes, Clip by Water, Calculate Variables*

```{r 1B.2_EastBay}

# CREATE ERASE FUNCTION
st_erase <- function(x, y) {
  st_difference(x, st_union(y))}

# ERASE WATER AREAS FROM CENSUS TRACTS
EB.water =
  area_water("CA", "Alameda", class = "sf") %>%
  st_transform(., CA_crs)
tracts.all <- st_erase(tracts.all, EB.water)

# GET CENTROIDS IN EAST BAY
tracts.all.centroid =
  tracts.all[c('GEOID','geometry')] %>%
  # centroid with largest poly to avoid water in city shapes
  st_centroid(tracts.all, of_largest_polygon = TRUE) %>%
  st_join(., EB.cities, left=TRUE) %>%
  distinct(GEOID, .keep_all = TRUE)
tracts.all.centroid = 
  tracts.all.centroid[tracts.all.centroid$city %in% is_EB,]
# SELECT TRACTS BY EAST BAY
center_geoms = tracts.all.centroid$GEOID
tracts.all = tracts.all[tracts.all$GEOID %in% center_geoms,]

# ERASE CITIES BY WATER
EB.cities <- st_erase(EB.cities, EB.water)

min_BART_dist_find = function(tract.pt){
  dists_bart = sapply(
    BART.stops$geometry, function(BART_pt) 
    st_distance(BART_pt, tract.pt))
  return(min(dists_bart))
}

tract_bart_distances = min_point_distances(
  tracts.all.centroid$geometry, tracts.all.centroid$GEOID,
  BART.stops$geometry, BART.stops$stop_id) %>%
  rename(GEOID=ID, dist_BART=distance, closest_BART=closest)

tracts.all.centroid = 
  tracts.all.centroid %>%
  merge(
    ., 
    tract_bart_distances,
    by='GEOID', all.x = TRUE
  )



# CALCULATE NEW COLUMNS BY WEIGHTING & LQ
tracts.all =
  tracts.all %>%
  merge(
    ., 
    tracts.all.centroid %>% as.data.frame() %>% select(GEOID, city, dist_BART, closest_BART) %>%
  rename(dist_BART_feet=dist_BART) %>%
  distinct(.),
    by='GEOID', all.x = TRUE
  ) %>%
  mutate(
    # distance to BART by miles
    dist_BART_miles=dist_BART_feet/mile,
    # area of tract that's not water
    land_area   = st_area(geometry),
    # median rent (in 2009) adjusted by 2019 inflation
    med_rent_inf = 
      ifelse(year == "2009", med_rent * 1.19, med_rent),
    # median rent (in 2009) adjusted by 2019 inflation
    med_HH_inc_inf = 
      ifelse(year == "2009", med_HH_inc * 1.19, med_HH_inc),
    # total population over housing units
    pop_units = tot_pop / tot_units
  )
attributes(tracts.all$land_area) = NULL
# population per sq mile
tracts.all$dens_pop    = tracts.all$tot_pop/(tracts.all$land_area/sqmile)
# housing units per sq mile
tracts.all$dens_units  = tracts.all$tot_units /(tracts.all$land_area/sqmile)

# for (yr in c(2019,2009)){
#   tracts.all[tracts.all$year==yr & !is.na(tracts.all$tot_emp),
#              'tot_EB_emp'] = sum(tracts.all[tracts.all$year==yr & !is.na(tracts.all$tot_emp)
#                                             ,][['tot_emp']])
#   tracts.all[tracts.all$year==yr & !is.na(tracts.all$tot_emp_info),
#              'tot_EB_emp_info'] = sum(tracts.all[tracts.all$year==yr & !is.na(tracts.all$tot_emp_info)
#                                                  ,][['tot_emp_info']])
#   # LOCATION QUOTIENT for information industry employees in the East Bay area
#   tracts.all[tracts.all$year==yr & !is.na(tracts.all$tot_emp),] = 
#     tracts.all[tracts.all$year==yr & !is.na(tracts.all$tot_emp),] %>%
#     mutate(
#       lq_emp_info = 
#         # ratio of info employees to total for tracts "local"
#         (tot_emp_info/tot_emp) / 
#         # ratio of info o total for East Bay "regional"
#         (tot_EB_emp_info / tot_EB_emp)
#     )}

# PLOT CURRENT DATA
ggplot() +
  # base tracts
  geom_sf(data=tracts.all, size=.5,
          color='grey80', fill='grey90') +
  # cities
  geom_sf(data=EB.cities, fill='transparent', 
          color=alpha('grey50',.5),
          lwd=1, linetype = "dashed") + 
  # centroids
  geom_sf(data=tracts.all.centroid, color='grey50', size=.5) +
  # BART routes
  geom_sf(data=BART.routes, color=BART.routes$route_s_nm, lwd=1) + 
  # BART stops
  geom_sf(data=BART.stops, fill='white',
          color='grey30', shape=21) + 
  # labels
  geom_text(
    data=EB.labels, check_overlap=TRUE,
    size = 2, fontface='bold', color='grey20',
    aes(x=lon,y=lat, label=label)) + 
  theme(axis.title=element_blank(), 
       axis.text=element_blank(),
       axis.ticks=element_blank()) + 
  mapTheme() + plot_limits()

BART.stops = 
  BART.stops %>%
  mutate(
    lon = map_dbl(geometry, ~st_centroid(.x)[[1]]),
    lat = map_dbl(geometry, ~st_centroid(.x)[[2]])
  ) 

# PLOT CURRENT DATA
ggplot() +
  # base tracts
  geom_sf(data=tracts.all, size=.5,
          color='grey80', fill='grey90') +
  # Tracts BART
  geom_sf(
    data=tracts.all[tracts.all$year==2019,], color=alpha('black',.1),
    aes(
      fill=tracts.all[tracts.all$year==2019,]$closest_BART, 
      alpha=tracts.all[tracts.all$year==2019,]$dist_BART_miles)) + 
  # BART stops
  geom_sf(data=BART.stops,
          color='black', shape=19, size=1) + 
  # labels
  geom_text(
    data=BART.stops, check_overlap=TRUE,
    size = 3, fontface=2, color='grey20',
    aes(
      x=lon+4000,
      y=lat, label=stop_id)) + 
  scale_fill_discrete(name="Closest BART") + 
  scale_alpha_continuous(breaks=c(.5,1,1.5,2), name="Distance", range=c(1,0)) + 
  theme(axis.title=element_blank(), 
       axis.text=element_blank(),
       axis.ticks=element_blank()) + 
  mapTheme() + plot_limits()

#at = st_as_sf(tracts.all)

```

## 1.B 3 Finding TOD Areas

*Buffering Transit (BART) Stops then Select Census Tracts by Area in TOD*

```{r 1B.3_TOD}

#tracts.all = st_as_sf(at)

# .5 MILE BUFFERS OF BART STOPS
BART.buffers.TOD = 
  BART.buffers[
    BART.buffers$distance == buffer_distance &
      BART.buffers$stop_id == 'ALL'
  ,]

# CLIP TRACTS BY BUFFER
clip = 
  st_intersection(BART.buffers.TOD, tracts.all[tracts.all$year == 2019,]) %>%
    dplyr::select(GEOID, land_area) %>%
    mutate(
      # find area that is in the buffer
      clip_area = st_area(geometry),
      # percent of buffer area to total
      pct_in_tod = as.vector(clip_area / land_area),
      Selection_Type = "Clip")
clipped = clip[c("GEOID","pct_in_tod","clip_area")]
clipped$geometry = NULL

# GET TOTAL & PERCENT LAND IN CLIP
tracts.all = 
  merge(tracts.all, clipped, by = "GEOID", all.x = TRUE)
tracts.all[is.na(tracts.all$clip_area), 'clip_area'] = 0
tracts.all[is.na(tracts.all$pct_in_tod), 'pct_in_tod'] = 0
tracts.all$clip_area = as.vector(tracts.all$clip_area)

# GET OTHER SELECTIONS FOR COMPARING
selection = 
  tracts.all[BART.buffers.TOD,] %>%
    dplyr::select(GEOID, pct_in_tod) %>%
    mutate(
      Selection_Type = "Spatial Selection")

selectCentroids =
  tracts.all.centroid[BART.buffers.TOD,] %>%
    st_drop_geometry() %>%
    left_join(dplyr::select(tracts.all, GEOID, pct_in_tod)) %>%
    st_sf() %>%
    mutate(
      Selection_Type = "Select by Centroids"
      )

# NARROW DOWN TOD TRACTS BASED ON CLIPPED STOPS BUFFER AREA (% and TOT)
tod_tracts = as.data.frame(tracts.all[
  # select tracts that had 50% of their land in .5mi stops buffer
  (tracts.all$pct_in_tod>=.5)|
  # select tracts that had:
  ( ### at least 20% of their land in the buffer, and
    (tracts.all$pct_in_tod<.5)&
    (tracts.all$pct_in_tod>.20)&
    ### at least .01 sq.miles (278,784 )
    (tracts.all$clip_area>278784)
  ),])[,'GEOID']

tracts.all$TOD = FALSE
tracts.all[tracts.all$GEOID %in% tod_tracts, "TOD"] = TRUE
tracts.TOD = tracts.all[tracts.all$TOD==TRUE,]

# SET UP GEOMETRY COLLECTIONS
focus.points = BART.stops$geometry
focus.polys = EB.cities %>% 
    st_convex_hull() %>% 
    st_cast(., "MULTIPOINT") %>%
    st_union() %>%
    st_cast(., "POINT") %>%
    st_sfc()
# GET DISTANCES OF TRANSIT STOPS AND THE FOCUS AREA BOUNDARY
distances_matrix = 
  outer(focus.points,focus.polys,
        FUN=Vectorize(st_distance, USE.NAMES = FALSE))
# GET CLOSEST DISTANCES OF TRANSIT STOPS AND THE FOCUS AREA BOUNDARY
min_BARTstop_EBboundary_distances = 
  apply(distances_matrix, 2, min)
# GET LARGEST CLOSEST DISTANCE (MILES) BETWEEN STOPS AND BOUNDARY
max_min_BART_EB_dist = 
  max(min_BARTstop_EBboundary_distances)/mile



ggplot() +
  geom_sf(
    data=EB.cities, fill='grey90') +
  geom_sf(data=clip, aes(fill=pct_in_tod)) +
  geom_sf(data=selection, aes(fill=pct_in_tod)) +
  geom_sf(data=selectCentroids, aes(fill=pct_in_tod)) +
  geom_sf(data=BART.buffers.TOD, fill='transparent', color='red', lwd=1) +
  geom_sf(
    data=tracts.TOD, fill='transparent', color='black'
          ) + 
  geom_sf(
    data=tracts.all[tracts.all$GEOID=='06001400200',], fill='yellow'
  )+ 
  geom_sf(
    data=BART.stops, fill='white',
    color='grey30', shape=21) + 
  scale_fill_steps2(
    low = "red",
    mid = "white",
    midpoint=.5,
    high = "blue",
    name='% within TOD buffer'
  ) + 
  facet_wrap(~Selection_Type) + 
  mapTheme() + plot_limits(poly.geometry = tracts.TOD)

```

```{r}




```

### 1.D Crime Data

Crime

```{r 1D_Crime}

api_key = "ZtfuhpSK1tX9XxWicYM7ew1lHSPYCF9mI2MnKZdBd"


```

------------------------------------------------------------------------

## 2 Four Time & Space Maps

***Comparing TOD & non-TOD Tracts between 2000 & 2019***

Median Rent, [Second], [Third], [Fourth]

### 2.A Population Density

*People per Square Foot (of Land Area)*



```{r 2A_variable1}
options(scipen=999)

# EB.water =
#   area_water("CA", "Alameda", class = "sf") %>%
#   st_transform(., CA_crs)
#EB.all = st_read(city_path) %>% st_union(.) %>% st_transform(., CA_crs) %>% st_buffer(10) %>% st_buffer(-10) 
   #%>% st_erase(., EB.water)
#EB.back_water = BART.stops %>% st_buffer(40*mile) %>% st_union() %>% st_erase(., EB.all)

plot_vari = function(
  focus_sf  = tracts.all,
  variable  = "dens_pop",
  qbreaks   = qBr(tracts.all, variable),
  sep = 1,
  title     = "Population Density 2009-2019", 
  subtitle  = "East Bay with ½ mile buffer from BART stations",
  legend_nm = variable,
  caption   = "Map 2.A",
  brewer_colors = 'Spectral',
  dig=0,
  last_cut=TRUE,
  last_variable='',
  last_suffix='',
  buff_col='red',
  col_rev=FALSE
){

focus_sf$cut_field = 
  focus_sf[[variable]] %>% 
  cut(., 
      breaks = qbreaks, dig.lab=10)
  
focus_sf = focus_sf %>%drop_na(cut_field)

cut_breaks <- sapply(focus_sf$cut_field, 
                  function(brk) brk %>% levels())

labels = cut_breaks %>%
  gsub(",", " to ", .) %>% str_sub(., 2, -2)
labels = unique(labels)
num = length(qbreaks)-1

for (i in seq(from=1,to=length(labels))){
  llist = labels[i] %>% str_split(., " to ")
  print(llist)
  
  lstr = function(l, remove=0){format(round(as.numeric(l), digit=dig)-remove, big.mark=",")}
           
  if (i == length(labels)){
    if (last_cut==FALSE || last_variable!=''){
      cap = lstr(llist[[1]][2], remove=sep)
      if (last_variable!=''){cap=last_variable}
      labels[i] = str_trim(paste(lstr(llist[[1]][1]), 'to', cap, last_suffix))}
    else {
      labels[i] = str_trim(paste(lstr(llist[[1]][1]), '+'))}
  } else if (i == 1){
    labels[i] = str_trim(paste(0, 'to', lstr(llist[[1]][2], remove=sep), last_suffix))
  } else {
    labels[i] = str_trim(paste(lstr(llist[[1]][1]), 'to', lstr(llist[[1]][2], remove=sep), last_suffix))
  }}
col_vals =brewer.pal(num, name=brewer_colors)
if (col_rev==TRUE){col_vals=rev(col_vals)}
return(
ggplot()+
  # geom_sf(data = EB.all, fill=alpha('grey50', .5), color=alpha('grey50', .5)) + 
  # geom_sf(data = EB.back_water, fill=alpha('cornflowerblue', .5), color='transparent') + 
  geom_sf(data  = EB.cities, fill='grey90')+
  geom_sf(data  = focus_sf, aes(fill    = cut_field), color='grey50') +
  
  scale_fill_manual(
    values=col_vals,
    labels = labels, name=legend_nm) +
  geom_sf(data=BART.buffers.TOD, fill='transparent', color=alpha(buff_col, alpha=.75), lwd=.75) +
  geom_sf(
    data=BART.stops, fill='white',
    color='grey30', shape=21) + 
  # geom_text(
  #   data=EB.labels, check_overlap=TRUE,
  #   size = 3.5, fontface='bold', color='black',
  #   aes(x=lon,y=lat, label=label)) + 
  labs(title = title, subtitle = subtitle,
       caption=caption) +
  guides(fill = guide_legend(reverse=T)) + 
  facet_wrap(~year)+
  mapTheme() + plot_limits()
)}
variable  = "dens_pop"
breaks = c(0, 10000,20000,30000, max(tracts.all[[variable]]))
#breaks = c(0, 1,2,5, max(tracts.all[[variable]]))
#breaks = seq(0, max(tracts.all[[variable]]), length.out = 5)
plot_vari(
  focus_sf  = tracts.all[!is.null(tracts.all[[variable]]),],
  variable  = variable,
  qbreaks   = breaks,
  title     = "Population Density 2009-2019", 
  caption   = "Map 2.A",
  brewer_colors = 'BuPu',
  legend_nm = "People per Sq.Mile\nof Tract Land Area",
  last_variable='60,000'
)

```

### 2.B Percent of Median Household Income spent on Rent

```{r 2B_variable2}

variable  = "pct_med_rent"

filt_sf = tracts.all[which( !is.na(tracts.all[[variable]]), arr.ind=TRUE),]
mx = max(filt_sf[[variable]])
#breaks = seq(0, mx, length.out = 6)
#breaks = c(0, 10000,20000,30000, mx)
breaks = c(0, 10,20,30,40, mx)
plot_vari(
  focus_sf  = filt_sf,
  variable  = variable,
  qbreaks   = breaks,
  title     = "Percent of Income Spent on Rent 2009-2019", 
  caption   = "Map 2.B",
  brewer_colors = 'RdYlGn',
  legend_nm = "% of Median Income\nSpent on Rent",
  last_variable='50',
  last_suffix='%',
  col_rev=TRUE,
  buff_col='blue'
)

```

### 2.C Percent of People who have moved in the Last Year

```{r 2C_variable3}

variable  = "pct_moved"

filt_sf = tracts.all[!is.na(tracts.all[[variable]]),]
filt_sf = filt_sf %>%   
  transform(., pct_moved=as.numeric(pct_moved))

filt_sf[[variable]] = filt_sf[[variable]] * 100
mx = max(filt_sf[[variable]])
#breaks = seq(0, mx, length.out = 5)
breaks = c(0, 15, 30, 45, mx)

plot_vari(
  focus_sf  = filt_sf,
  variable  = variable,
  qbreaks   = breaks,
  sep=1,
  dig=2,
  title     = "Percent of Population that Moved in Last Year 2009-2019", 
  caption   = "Map 2.C",
  brewer_colors = 'PuRd',
  legend_nm = "% of Population that did not\nreside in their current house\n a year ago",
  last_variable='90',
  last_suffix='%',
  col_rev=FALSE
)

```

### 2.D Location Quotient of People employed in the Information Industry

*Ratio of the amount of Information industry employees (e.g. software, technology, & media companies)* *to the total amount of employees — both in the Census Tract & Region (East Bay)*

```{r 2D_variable4}

# tracts.all = tracts.all %>%   
#   mutate(pct_emp_info = (tot_emp_info/tot_emp)*100)
#   #transform(., lq_emp_info=as.numeric(lq_emp_info))

variable  = "pct_emp_info"

filt_sf = tracts.all[!is.na(tracts.all[[variable]]),]

mx = max(filt_sf[[variable]])
#breaks = seq(0, mx, length.out = 6)
breaks = c(0, 5, 10, 15, 20,mx)

plot_vari(
  focus_sf  = filt_sf,
  variable  = variable,
  qbreaks   = breaks,
  sep=1,
  dig=1,
  title     = "Percent of Employed Residents in the Information Industry 2009-2019", 
  caption   = "Map 2.D",
  brewer_colors = 'OrRd',
  legend_nm = "% of Information Industry Employees\nout of all Employed Residents\ne.g. Technology, Software, Media",
  last_variable='30',
  last_suffix='%',
  buff_col='Black'
)
```

------------------------------------------------------------------------

## 3 Bar Plot

*One grouped bar plot making these same comparisons*

```{r 3_barplot}

```

------------------------------------------------------------------------

## 4 Table

*One table making these same comparisons*

```{r 4_table}

```

------------------------------------------------------------------------

## 5 Graduated Symbol Maps

*Two Graduated Symbol Maps within 0.5 miles transit stations*

### 5.B Map of Population within ½ Mile of BART Stations

```{r 5A_pop}

```

### 5.B Map of Rent within ½ Mile of BART Stations

```{r 5B_rent}

```

------------------------------------------------------------------------

## 6 Geom Line Plots

***Rent & Crime compared to the Distance to BART stations***

```{r 6_geom_line}

```

------------------------------------------------------------------------

## 7 Policy Brief

------------------------------------------------------------------------

## Load data from {tidycensus}

```{r acs_vars, cache = TRUE, message = FALSE, warning = FALSE, results=FALSE}
acs_vars <- c(
    "B01001_001",    # ACS total Pop stimat
    "B15003_001",
    "B25002_001",     # stimat of total housing units
    "B25002_003",     # Numbr of vacant housing units
    "B19013_001",    # Mdian HH Incom ($)
    "B02001_002",  # Popl dscribing thmslvs as "whit alon"
    "B07010_001",     # stimat!!Total Individuals
    "B07010_002",  # stimat!!Total:!!No incom
    "B07010_011", # stimat!!Total:!!With incom:!!$75,000 or mor
    "B07010_023",   # stimat!!Total:!!Movd within sam county:
    "B07010_034",  # stimat!!Total:!!Movd from diffrnt county:
    "B07010_045",   # stimat!!Total:!!Movd from diffrnt country:
    "B07010_012",  # Estimate!!Total:!!Same house 1 year ago:
    "B15003_023",  #Estimate!!Total:!!Disc jockeys, except radio
    "B15003_024",  #Estimate!!Total:!!Disc jockeys, except radio
    "B15003_025"  #Estimate!!Total:!!Disc jockeys, except radio

              ) 

myTracts <- c(
    "42101007400", 
    "42101007300", 
    "42101008000", 
    "42101007800", 
    "42101007700",
    "42101008000",
    "42101007900",
    "42101008802", # just west of UPENN
    #"42101036900", # UPENN, hospitals, woodlands
    #"42101008801", # UPENN
    "42101008702",
    "42101008701",
    "42101008601"
              )


acsTractsPHL.2019.sf <- get_acs(geography = "tract",
                             year = 2019,
                             variables = acs_vars,
                             geometry = TRUE,
                             state  = "PA",
                             county = "Philadelphia",
                             output = "wide") %>%
  dplyr::select (GEOID, NAME, all_of(paste0(acs_vars,"E"))) %>%
  rename (
      total_pop.2019 = B01001_001E,    # ACS total Pop estimate
      total_25yrpop.2019 = B15003_001E,
      total_HU.2019 = B25002_001E,     # Estimate of total housing units
      total_vacant.2019 = B25002_003E,     # Number of vacant housing units
      med_HH_income.2019 = B19013_001E,    # Median HH Income ($)
      total_white.2019 = B02001_002E,  # People describing themselves as "white alone"
      total_indi.2019 = B07010_001E,     # Estimate!!Total Individuals
      total_no_income.2019 = B07010_002E,  # Estimate!!Total:!!No income
      total_income_75k.2019 = B07010_011E, # Estimate!!Total:!!With income:!!$75,000 or more
      total_moved_incnty.2019 = B07010_023E,   # Estimate!!Total:!!Moved within same county:
      total_moved_outcnty.2019 = B07010_034E,  # Estimate!!Total:!!Moved from different county:
      total_moved_outusa.2019 = B07010_045E,   # Estimate!!Total:!!Moved from different country:
      total_same_house_1yr.2019 = B07010_012E,  # Estimate!!Total:!!Same house 1 year ago:
      total_masters.2019 = B15003_023E
  ) %>%
  mutate(
    Neighborhood = ifelse(GEOID %in% myTracts,
                               "CLARK PARK",
                               "REST OF PHILADELPHIA"),
    moved_1yr_PCT.2019 = (1 - total_same_house_1yr.2019 / total_indi.2019 )*100,
    masters_PCT.2019 = ((total_masters.2019 + B15003_024E+ B15003_025E) / total_25yrpop.2019 )*100
    )
```

## Transform to WGS84 with {sf}

```{r}
acsTractsPHL.2019.sf <- acsTractsPHL.2019.sf %>% 
  st_transform(crs = "EPSG:4326")
```

## Plot with {ggplot2}

```{r ggplot_geom_sf, warning = FALSE, echo = FALSE}
max_pct = max(acsTractsPHL.2019.sf$moved_1yr_PCT.2019[is.finite(acsTractsPHL.2019.sf$moved_1yr_PCT.2019)])

ggplot()+
  # POLYGON color 
  geom_sf(data = acsTractsPHL.2019.sf, 
          aes(fill = moved_1yr_PCT.2019),
          color = "transparent")+
  # blank on top
  geom_sf(data = acsTractsPHL.2019.sf %>%
            filter(Neighborhood == "CLARK PARK") %>%
            st_union(),
            color = "black",
            size=1, #linetype="longdash",
            fill = "transparent"
          ) + 
  scale_fill_gradient2(
      low="green4", mid="white", high="red4", midpoint=20,
      breaks = c(0,20,40,60), labels = c("0%","20%","40%","60%"),
      name="% of New Residents")+
  guides(fill = guide_colourbar(barheight = 10))+
  labs(
    title = "Percentage of individuals who have moved in the last year",
    subtitle = "Focus on the Clark Park neighborhood") +
  theme(plot.title = element_text(hjust = 0.5), axis.title.x=element_blank(), 
        axis.text.x=element_blank(), axis.ticks.x=element_blank(),
        axis.title.y=element_blank(), axis.text.y=element_blank(), 
        axis.ticks.y=element_blank(),
        panel.background = element_rect(fill='gray'))
```

\# )

\#brewer.pal(3, name="Dark2")

```{r ggplot_geom_sf, warning = FALSE, echo = FALSE}

library(RColorBrewer)


ggplot()+
  #POLYGON
  geom_sf(data = acsTractsPHL.2019.sf,
          fill = "white",
          color = "grey75"
          )+
  # POINT
  geom_sf(data = acsTractsPHL.2019.sf  %>%
          st_centroid(),                # to centroid
          shape = 21, color='grey10',
          aes(
            size = masters_PCT.2019,    # set point size by column value
            fill = masters_PCT.2019     # set point fill ('color') by column value
          )) +
  # Scale for the Point Size
  scale_size_continuous(
          range = c(0,6),             # range of point sizes
          breaks = c(0,20,40,60),       # value breaks/bins of point size
          labels = c("0 to 19 %", "20 to 39 %", "40 to 59%", "60+ %"), 
                                        # legend labels
          name="% of People over 25yrs with a \nMaster's, Doctoral, or Professional Degree"
          )+
  scale_fill_stepsn(                    # binned scale of point fill
          colors = RColorBrewer::brewer.pal( # pulling ColorBrewer list of colors
                      4,                # amount of bins
                      name="BuPu"       # ColorBrewer palette
                      ),
          breaks = c(0,20,40,60),       # value breaks/bins of point size
          guide = FALSE                 # remove legend (so we can have one combo)
          )+
    labs(
          title = "Percentage of Adults who earned \n a Master's Degree or Higher",
          ) +
    theme(
          axis.title=element_blank(), 
          axis.text=element_blank(), axis.ticks=element_blank(), # remove ticks
          panel.background = element_rect(fill='gray')
          )+
    guides(
          size = guide_legend(
              override.aes = list(fill = brewer.pal(4, name="BuPu"))
          ))                            # add the ColorBrewer list to the legend
```
